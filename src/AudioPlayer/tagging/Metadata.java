
package AudioPlayer.tagging;

import AudioPlayer.playlist.Item;
import AudioPlayer.playlist.PlaylistItem;
import AudioPlayer.playlist.PlaylistManager;
import AudioPlayer.tagging.Chapters.Chapter;
import AudioPlayer.tagging.Chapters.MetadataExtended;
import AudioPlayer.tagging.Cover.Cover;
import AudioPlayer.tagging.Cover.Cover.CoverSource;
import AudioPlayer.tagging.Cover.FileCover;
import AudioPlayer.tagging.Cover.ImageCover;
import java.awt.image.BufferedImage;
import java.awt.image.RenderedImage;
import java.io.File;
import java.io.IOException;
import static java.lang.Integer.parseInt;
import static java.lang.annotation.ElementType.METHOD;
import java.lang.annotation.Retention;
import static java.lang.annotation.RetentionPolicy.SOURCE;
import java.lang.annotation.Target;
import java.net.URI;
import java.time.DateTimeException;
import java.time.Year;
import java.util.ArrayList;
import static java.util.Collections.EMPTY_LIST;
import java.util.List;
import java.util.Objects;
import java.util.function.Function;
import static java.util.stream.Collectors.joining;
import javafx.scene.image.Image;
import javafx.scene.paint.Color;
import javafx.util.Duration;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Transient;
import main.App;
import org.jaudiotagger.audio.AudioFile;
import org.jaudiotagger.audio.AudioHeader;
import org.jaudiotagger.audio.mp3.MP3File;
import org.jaudiotagger.audio.wav.WavTag;
import org.jaudiotagger.tag.FieldKey;
import org.jaudiotagger.tag.Tag;
import org.jaudiotagger.tag.TagField;
import org.jaudiotagger.tag.flac.FlacTag;
import org.jaudiotagger.tag.id3.AbstractID3v2Frame;
import org.jaudiotagger.tag.id3.ID3v24Frames;
import org.jaudiotagger.tag.id3.ID3v24Tag;
import org.jaudiotagger.tag.id3.framebody.FrameBodyPOPM;
import org.jaudiotagger.tag.images.Artwork;
import org.jaudiotagger.tag.mp4.Mp4FieldKey;
import org.jaudiotagger.tag.mp4.Mp4Tag;
import util.ClassName.Name;
import util.File.AudioFileFormat;
import util.File.FileUtil;
import static util.File.FileUtil.EMPTY_COLOR;
import static util.File.FileUtil.EMPTY_URI;
import util.File.ImageFileFormat;
import util.Util;
import static util.Util.emptifyString;
import static util.Util.mapEnumConstant;
import util.access.FieldValue.FieldEnum;
import util.access.FieldValue.FieldedValue;
import util.dev.Log;
import util.dev.TODO;
import static util.functional.Util.isIn;
import static util.functional.Util.stream;
import util.parsing.Parser;
import util.units.Bitrate;
import util.units.FileSize;
import util.units.FormattedDuration;
import util.units.NofX;

/**
 * Information about audio file.
 * Provided by reading tag and audio file header (mostly).
 * Everything that is possible to know about the audio file is accessible through
 * this class. This class also provides some non-tag, application specific
 * or external information associated with this song, like cover files.
 * <p>
 * The class is practically immutable and does not provide any setters, nor
 * allows updating of its state or any of its values.
 * <p>
 * Metadata can be empty and hsould be used instead of null. See {@link #EMPTY}
 * <p>
 * The getters of this class return mostly string. For empty fields the output
 * is "" (empty string) and for non-string getters it varies, but it is never 
 * null. See documentation
 * for the specific field. The rule is however, that the check for empty value
 * should be necessary only in rare cases.
 * <p>
 * Every field returns string, primitive, or Object with toString method that
 * returns the best possible string representation of the field's value, including
 * its empty value.
 * Therefore, if framework were to be used, simply obtaining values for all
 * fields and using natural String (toString()) conversion is all that is needed.
 * As for how to leverage this: see {@link #getField()}.
 * 
 * @author uranium
 */
@Name("Library Song")
@Entity(name = "MetadataItem")
public final class Metadata extends MetaItem<Metadata> implements FieldedValue<Metadata,Metadata.Field> {
    // note: for some fields the initialized values below are not their
    // 'default' values. Rather, those are autogenerated when requested
    
    // identification fields
    // note: there were some problems with serializing URI, although it should be
    // supported. For now... String it is. Use URI.toString(), not getPath()!
    // Might change to URI later.
    // Before anyone attepts to do so, note that this is primary key we are talking
    // about.
    //
    // primary key & resource identifier. see getURI() and consturctors.
    // for empty metadata use special 'empty' uri 
    @Id
    private String uri = FileUtil.EMPTY_URI.toString();
    
    // header fields
    private long filesize = 0;
    private String encoding = "";
    private int bitrate = -1;
    private String encoder = "";
    private String channels = "";
    private String sample_rate = "";
    private double duration = 0;
    // tag fields
    private String title = "";
    private String album = "";
    private String artist = "";
    @Transient
    private List<String> artists = null; // unsupported as of now
    private String album_artist = "";
    private String composer = "";
    private String publisher = "";
    private int track = -1;
    private int tracks_total = -1;
    private int disc = -1;
    private int discs_total = -1;
    private String genre = "";
    private int year = -1;
    @Transient
    private Artwork cover = null;
    private int rating = -1;
    @Transient
    private double ratingP = -1;
    private int playcount = -1;
    private String category = "";
    private String comment = "";
    private String lyrics = "";
    private String mood = "";
    // some custom fields contain synthetic field's values
    private String custom1 = "";
    private String custom2 = "";
    private String custom3 = "";
    private String custom4 = "";
    private String custom5 = "";
    
    /** 
     * EMPTY metadata. Substitute for null. Always use instead of null. Also
     * corrupted items should transform into EMPTY metadata.
     * <p>
     * All fields are at their default values.
     * <p>
     * There are two ways to check whether Metadata object is EMPTY. Either use
     * reference operator this == Metadata.EMPTY or call {@link #isEmpty()}.
     * <p>
     * Note: The reference operator works, because there is always only one
     * instance of EMPTY metadata.
     */
    public static final Metadata EMPTY = new Metadata();
    
    public static String metadataID(URI u) {
        return u.toString();
    }
    
    // public - this type of metadata is simply a conversion, harmless & we need
    // to allow the access from Item subclasses
    /**
     * Creates metadata from specified item. Attempts to fill as many metadata 
     * information fields from the item as possible, leaving everything else empty.
     * For example, if the item is playlist item, sets artist, length and title fields.
     */
    public Metadata(Item item) {
        uri = item.getURI().toString();
        if(item instanceof PlaylistItem) {
            PlaylistItem pitem = (PlaylistItem)item;
            artist = pitem.getArtist();
            duration = pitem.getTime().toMillis();
            title = pitem.getTitle();
        }
    }
    
    // constructs empty metadata
    // private - do not allow anyone create new empty metadata
    private Metadata() {
        uri = EMPTY_URI.toString();
    }
    
    // the constructor for creating new metadata by reading the tag
    // package access - only allow the MetadataReaders to create metadata like this
    /**
     * Reads and creates metadata info for file.
     * Everything is read at once. There is no additional READ operation after the
     * object has been created.
     * 
     */
    Metadata(AudioFile audiofile) {
        File file = audiofile.getFile().getAbsoluteFile();
        uri = file.toURI().toString();
        filesize = FileSize.inBytes(file);
        
        Tag tag = audiofile.getTagOrCreateAndSetDefault();
        loadGeneralFields(audiofile, tag);
        switch (getFormat()) {
            case mp3:   loadSpecificFieldsMP3((MP3File)audiofile);  break;
            case flac:  loadFieldsFLAC((FlacTag)tag);       break;
            case ogg:   loadFieldsOGG(tag);                 break;
            case wav:   loadFieldsWAV((WavTag)tag);         break;
            case mp4:
            case m4a:   loadFieldsMP4((Mp4Tag)tag);         break;
            default: throw new AssertionError("Illegal case in switch");
        }        
        
    }
    /** loads all generally supported fields  */
    private void loadGeneralFields(AudioFile aFile, Tag tag) {
        AudioHeader header = aFile.getAudioHeader();
        
        bitrate = (int)header.getBitRateAsNumber();
        duration = 1000 * header.getTrackLength();
        // format and encoding type are switched in jaudiotagger library...
        encoding = emptifyString(header.getFormat());
        channels = emptifyString(header.getChannels());
        sample_rate = emptifyString(header.getSampleRate());
        
        if(tag==null) {
            Log.warn("Tag unsupported in item being read: " + getURI());
            return;
        }
        
        encoder = getGeneral(tag,FieldKey.ENCODER);
        
        title = getGeneral(tag,FieldKey.TITLE);
        album = getGeneral(tag,FieldKey.ALBUM);
//        artists = getGenerals(tag,FieldKey.ARTIST);
        artist = getGeneral(tag,FieldKey.ARTIST);
        album_artist = getGeneral(tag,FieldKey.ALBUM_ARTIST);
        composer = getGeneral(tag,FieldKey.COMPOSER);
        
        // track
        String tr = getGeneral(tag,FieldKey.TRACK);
        int i = tr.indexOf('/');
        if(i!=-1) {
            // some apps use TRACK for "x/y" string format, we cover that
            track = getNumber(tr.substring(0, i));
            tracks_total = getNumber(tr.substring(i+1, tr.length()));
        } else {
            track = getNumber(tr);
            tracks_total = getNumber(tag,FieldKey.TRACK_TOTAL);
        }
        
        // disc
        String dr = getGeneral(tag,FieldKey.DISC_NO);
        int j = dr.indexOf('/');
        if(j!=-1) {
            // some apps use DISC_NO for "x/y" string format, we cover that
            disc = getNumber(dr.substring(0, j));
            discs_total = getNumber(dr.substring(j+1, dr.length()));
        } else {
            disc = getNumber(dr);
            discs_total = getNumber(tag,FieldKey.DISC_TOTAL);
        }
        
        playcount = getNumber(tag, FieldKey.CUSTOM3);
        genre = getGeneral(tag,FieldKey.GENRE);
        year = getNumber(tag,FieldKey.YEAR);
        category = getGeneral(tag,FieldKey.GROUPING);
        comment = getComment(tag);
        lyrics = getGeneral(tag,FieldKey.LYRICS);
        mood = getGeneral(tag,FieldKey.MOOD);
        custom1 = getGeneral(tag,FieldKey.CUSTOM1);
        custom2 = getGeneral(tag,FieldKey.CUSTOM2);
        custom3 = getGeneral(tag,FieldKey.CUSTOM3);
        custom4 = getGeneral(tag,FieldKey.CUSTOM4);
        custom5 = getGeneral(tag,FieldKey.CUSTOM5);
    }
    
    
    // use to debug tag
    // tag.getFields().forEachRemaining(f->System.out.println(f.getId()+" "+f));
    
    
    private String getGeneral(Tag tag, FieldKey f) {
        if (!tag.hasField(f)) return "";
        return Util.emptifyString(tag.getFirst(f));
    }
    private int getNumber(Tag tag, FieldKey field) {
        return getNumber(getGeneral(tag, field));
    } 
    private int getNumber(String s) {
        try {
            return s.isEmpty() ? -1 : parseInt(s);
        } catch(NumberFormatException e){
            return -1;
        }
    }
    // use this to get comment, not getField(COMMENT); because it is bugged
    private String getComment(Tag tag) { 
        // there is a bug where getField(Comment) returns CUSTOM1 field, this is workaround
        // this is how COMMENT field look like:
        //      Language="English"; Text="example"; 
        // this is how CuSTOM fields look like:  
        //      Language="Media Monkey Format"; Description="Songs-DB_Custom5"; Text="example"; 
        if (!tag.hasField(FieldKey.COMMENT)) return "";
        int i = -1;
        List<TagField> fields = tag.getFields(FieldKey.COMMENT);
        // get index of comment within all comment-type tags
        for(TagField t: fields) // custom
            if (!t.toString().contains("Description"))
                i = fields.indexOf(t);
        if(i>-1) return tag.getValue(FieldKey.COMMENT, i);
        else return "";
    }
    private List<String> getGenerals(Tag tag, FieldKey f) {
        List<String> out = new ArrayList<>(); 
        if (!tag.hasField(f)) return out;
        
        try{
//        for (TagField field: tag.getFields(f)) {
//            String tmp = field.toString();
//                   tmp = tmp.substring(6, tmp.length()-3);
//            out.add(Util.emptifyString(tmp));
//        }
        for (String val: tag.getAll(f))
            out.add(Util.emptifyString(val));
        } catch(Exception w) { 
            // contrary to what compiler is saying, no, exception is not too broad
            // do not change the exception or some weird stuff will be happening
            // jaudiotagger throws some additional exceptions here and there...
            // needs to be nvestigated
            w.printStackTrace();
        }
        return out;
    }
    
    
    private void loadSpecificFieldsMP3(MP3File mp3) {
        Objects.requireNonNull(mp3);
        
        // we obtain the tag
        ID3v24Tag tag = mp3.getID3v2TagAsv24();
        // if no tag is present we get null, nothing to read -> leave default values
        if(tag==null) {
            Log.warn("MP3 file is missing tag: " + getURI() + ". Some values will be left empty.");
            return;
        }
        
        // we obtain the POPM field (rating + counter + mail/user)
        AbstractID3v2Frame frame1 = tag.getFirstField(ID3v24Frames.FRAME_ID_POPULARIMETER);
        // if not present we get null and leave default values
        if (frame1 != null) {
            // we obtain body for the field
            FrameBodyPOPM body1 = (FrameBodyPOPM) frame1.getBody();
            // once again the body of the field might not be there
            if (body1 != null) {
                long rat = body1.getRating(); //returns null if empty
                long cou = body1.getCounter(); //returns null if empty
                
                // i do not know why the values themselves are Long, but we only need int
                // both for rating and playcount.
                // all is good until the tag is actually damaged and the int can really
                // overflow during conversion and we get ArithmeticException
                // so we catch it and ignore the value
                try {
                    rating = Math.toIntExact(rat);
                } catch (ArithmeticException e){}

                try {
                    int pc = Math.toIntExact(cou);
                    if(pc>playcount) playcount = pc;
                } catch (ArithmeticException e) {}
            }
        }
        
        // we obtain publisher
        publisher = emptifyString(tag.getFirst(ID3v24Frames.FRAME_ID_PUBLISHER));
    }
    private void loadFieldsWAV(WavTag tag) {
        // unfortunately WAV is completely unsupported, as far as i know it doesnt have tag
        rating = -1;
        publisher = "";
    }
    private void loadFieldsMP4(Mp4Tag tag) {
        // RATING --------------------------------------------------------------
        // id: 'rate'
        // all are equivalent:
        //      tag.getFirst(FieldKey.RATING)
        //      tag.getValue(FieldKey.RATING,0)
        //      tag.getItem("rate",0) 
        int r = getNumber(tag, FieldKey.RATING);
        // sometimes we get unintelligible values for some reason (dont ask me),
        // Mp3Tagger app can recognize them somehow
        // the values appear consistent so lets use them
        if(r==12592) rating = 100;
        else if(r==14384) rating = 80;
        else if(r==13872) rating = 60;
        else if(r==13360) rating = 40;
        else if(r==12848) rating = 20;
        // handle normally
        else rating = (r<0 || r>100) ? -1 : r;
        
        // PUBLISHER -----------------------------------------------------------
        // id: '----:com.nullsoft.winamp:publisher'
        //      tag.getFirst(FieldKey.PRODUCER) // nope
        //      tag.getFirst(Mp4FieldKey.WINAMP_PUBLISHER) // works
        //      tag.getFirst(Mp4FieldKey.LABEL) // not same as WINAMP_PUBLISHER, but perhaps also valid
        //      tag.getFirst(FieldKey.KEY)
        publisher = emptifyString(tag.getFirst(Mp4FieldKey.WINAMP_PUBLISHER));
        if(publisher.isEmpty()) publisher = emptifyString(tag.getFirst(Mp4FieldKey.MM_PUBLISHER));
    }
    private void loadFieldsOGG(Tag tag) {
        rating = -1;
        publisher = "";
        // try to get category as winamp does it
        if(category.isEmpty()) category = Util.emptifyString(tag.getFirst("CATEGORY"));
    }
    private void loadFieldsFLAC(FlacTag tag) {
        rating = -1;
        publisher = "";
        // try to get category as winamp does it
        if(category.isEmpty()) category = Util.emptifyString(tag.getFirst("CATEGORY"));
    }

/******************************************************************************/  

    @Override
    public String getId() {
       return uri;
    }
    public void setId(String id) {
        this.uri = id;
    }
    
    @Override 
    public URI getURI() {
        return URI.create(uri.replace(" ","%20"));
    }
    
    /**
     * @see #EMPTY
     * @return true if this metadata is empty.
     */
    public boolean isEmpty() {
        return this == EMPTY;
    }
    
    /** @{@inheritDoc} */
    @Override
    @MetadataFieldMethod(Field.PATH)
    public String getPath() {
        return isEmpty() ? "" : super.getPath();
    }
    
    /** @{@inheritDoc} */
    @Override
    @MetadataFieldMethod(Field.FILENAME)
    public String getFilename() {
        return super.getFilename();
    }
    
    /** @{@inheritDoc} */
    @MetadataFieldMethod(Field.FILESIZE)
    @Override
    public FileSize getFilesize() {
        return new FileSize(filesize);
    }
    
    /** {@link getFilesize()} in bytes */
    public long getFilesizeInB() {
        return filesize;
    }
    
    /** {@inheritDoc} */
    @Override
    @MetadataFieldMethod(Field.FORMAT)
    public AudioFileFormat getFormat() {
        return AudioFileFormat.of(uri);
    }

    /** @return the bitrate */
    @MetadataFieldMethod(Field.BITRATE)
    public Bitrate getBitrate() {
        return bitrate==-1 ? null : new Bitrate(bitrate);
    }
    
    /**
     * For example: Stereo.
     * @return channels as String
     */
    @MetadataFieldMethod(Field.CHANNELS)
    public String getChannels() {
        return channels;
    }
    
    /**
     * For example: 44100
     * @return 
     */
    @MetadataFieldMethod(Field.SAMPLE_RATE)
    public String getSampleRate() {
        return sample_rate;
    }
    
    /**
     * For example: MPEG-1 Layer 3.
     * @return encoding type
     */
    @MetadataFieldMethod(Field.ENCODING)
    public String getEncodingType() {
        return encoding;
    }
    
    /** @return the encoder or empty String if not available. */
    @MetadataFieldMethod(Field.ENCODER)
    public String getEncoder() {
        return encoder;
    }
    
    /** @return the length */
    @MetadataFieldMethod(Field.LENGTH)
    public FormattedDuration getLength() {
        return new FormattedDuration(duration);
    }
    
    /** @return the length in milliseconds */
    public double getLengthInMs() {
        return duration;
    }
    
/******************************************************************************/    
    
    /** @return the title "" if empty. */
    @MetadataFieldMethod(Field.TITLE)
    public String getTitle() {
        return title;
    }
    
    /** @return the album "" if empty. */
    @MetadataFieldMethod(Field.ALBUM)
    public String getAlbum() {
        return album;
    }
    
    /**
     * Returns list all of artists.
     * @return the artist
     * empty List if empty.
     */
    public List<String> getArtists() {
        return artists;
    }
    
    /**
     * Returns all of artists as a String. Uses ", " separator. One line
     * Empty string no arist.
     * @return 
     */
    public String getArtistsAsString() {
        String temp = "";
        for (String s: artists) {
            temp = temp + ", " + s;
        }
        return temp;
    }
    
    /**
     * Returns first artist found in tag.
     * If you want to get all artists dont use this method.
     * @return the first artist
     * "" if empty.
     */
    @MetadataFieldMethod(Field.ARTIST)
    public String getArtist() {
        return App.ALBUM_ARTIST_WHEN_NO_ARTIST && artist.isEmpty() ? album_artist : artist;
    }
    
    /** @return the album_artist, "" if empty. */
    @MetadataFieldMethod(Field.ALBUM_ARTIST)
    public String getAlbumArtist() {
        return album_artist;
    }

    /** @return the composer, "" if empty. */
    @MetadataFieldMethod(Field.COMPOSER)
    public String getComposer() {
        return composer;
    }

    /** @return the publisher, "" if empty. */
    @MetadataFieldMethod(Field.PUBLISHER)
    public String getPublisher() {
        return publisher;
    }

    /** @return the track, -1 if empty. */
    @MetadataFieldMethod(Field.TRACK)
    public int getTrack() {
        return track;
    }
    
    /** @return the tracks total, -1 if empty. */
    @MetadataFieldMethod(Field.TRACKS_TOTAL)
    public int getTracksTotal() {
        return tracks_total;
    }
    
    /**
     * Convenience method. Returns complete info about track order within album in
     * format track/tracks_total. If you just need this information as a string
     * and dont intend to sort or use the numerical values
     * then use this method instead of {@link #getTrack()} and {@link #getTracksTotal())}.
     * <p>
     * If disc or disc_total information is unknown the respective portion in the
     * output will be substitued by character '?'.
     * Example: 1/1, 4/23, ?/?, ...
     * @return track album order information.
     */
    @MetadataFieldMethod(Field.TRACK_INFO)
    public NofX getTrackInfo() {
        return new NofX(track, tracks_total);
    }
    
    /** @return the disc, -1 if empty. */
    @MetadataFieldMethod(Field.DISC)
    public int getDisc() {
        return disc;
    }
    
    /** @return the discs total, -1 if empty. */
    @MetadataFieldMethod(Field.DISCS_TOTAL)
    public int getDiscsTotal() {
        return discs_total;
    }

    
    /**
     * Convenience method. Returns complete info about disc number in album in
     * format disc/discs_total. If you just need this information as a string
     * and dont intend to sort or use the numerical values
     * then use this method instead of {@link #getDisc() ()} and {@link #getDiscsTotal()}.
     * <p>
     * If disc or disc_total information is unknown the respective portion in the
     * output will be substitued by character '?'.
     * Example: 1/1, ?/?, 5/?, ...
     * @return disc information.
     */
    @MetadataFieldMethod(Field.DISCS_INFO)
    public NofX getDiscInfo() {
        return new NofX(disc, discs_total);
    }
    
    /** @return the genre, "" if empty. */
    @MetadataFieldMethod(Field.GENRE)
    public String getGenre() {
        return genre;
    }

    /** @return the year or Year.of(-1) if empty. */
    @MetadataFieldMethod(Field.YEAR)
    public Year getYear() {
        try {
            return Year.of(year);
        } catch (DateTimeException e) {
            return Year.of(-1);
        }
    }
    
    /**
     * Returns cover from the respective source.
     * @param source
     */
    public Cover getCover(CoverSource source) {
        switch(source) {
            case TAG: return getCover();
            case DIRECTORY: return new FileCover(getCoverFromDirAsFile(), "");
            case ANY : {
                Cover c = getCover();
                return c.getImage()!=null 
                        ? c 
                        : new FileCover(getCoverFromDirAsFile(), "");
            }
            default: throw new AssertionError("Corrupted switch statement");
        }
    }
    
    private void loadCover() {
        if(cover!=null || cover_loaded) return;
        cover_loaded = true;
        AudioFile af = isFileBased() ? readAudioFile(getFile()) : null;
        Tag tag = af!=null ? af.getTagOrCreateAndSetDefault() : null;
        if(tag==null) {
            Log.warn("Tag unsupported in item being read: " + getURI());
            cover = null;
        } else {
            cover = tag.getFirstArtwork();
        }
    }
    
    @MetadataFieldMethod(Field.COVER)
    private Cover getCover() {
        try {
            loadCover();
            if(cover==null) return new ImageCover((Image)null, getCoverInfo());
            else return new ImageCover((BufferedImage) cover.getImage(), getCoverInfo());
        } catch (IOException ex) {
            return new ImageCover((Image)null, getCoverInfo());
        }
    }
    
    @Transient
    private boolean cover_loaded = false;
    
    @MetadataFieldMethod(Field.COVER_INFO)
    private String getCoverInfo() {
        try {
            loadCover();
            return cover.getDescription() + " " + cover.getMimeType() + " "
                       + ((RenderedImage)cover.getImage()).getWidth() + "x"
                       + ((RenderedImage)cover.getImage()).getHeight();
        } catch(IOException | NullPointerException e) {
            // nevermind errors. Return "" on fail.
            return "";
        }
    }
    
    /**
     * Identical to getCoverFromDir() method, but returns the image file
     * itself. Only file based items.
     * <p>
     * If the Image object of the cover suffices, it is recommended to
     * avoid this method, or even better use getCoverFromAnySource()
     * @return 
     */
    @TODO(note = "ensure null doesnt cause any problems")
    private File getCoverFromDirAsFile() {
        if(!isFileBased()) return null;
        
        File dir = getFile().getParentFile();
        if (!FileUtil.isValidDirectory(dir)) return null;
                
        File[] files;
        files = dir.listFiles( f -> {
            String filename = f.getName();
            int i = filename.lastIndexOf('.');
            if(i == -1) return false; 
            String name = filename.substring(0, i);
            return (ImageFileFormat.isSupported(f.toURI()) && (
                        name.equalsIgnoreCase("cover") ||
                        name.equalsIgnoreCase("folder") ||
                        name.equalsIgnoreCase(getFilenameFull()) ||
                        name.equalsIgnoreCase(getFilename()) ||
                        name.equalsIgnoreCase(getTitle()) ||
                        name.equalsIgnoreCase(getAlbum())
                ));
        });
        
        if (files.length == 0) return null;
        else return files[0];
    }
    
    /** @return the rating or -1 if empty. */
    @MetadataFieldMethod(Field.RATING_RAW)
    public int getRating() {
        return rating==-1 ? 0 : rating;
    }
    
    /** 
     * Recommended method to use to obtain rating.
     * @return the rating in 0-1 percent range */
    @MetadataFieldMethod(Field.RATING)
    public double getRatingPercent() {
        return getRating()/(double)getRatingMax();
//        if(ratingP==-1) ratingP = getRating()/(double)getRatingMax();
//        return ratingP;
    }
    
    /**
     * @param max_stars
     * @return the current rating value in 0-max_stars value system. 0 if not available.
     */
    public double getRatingToStars(int max_stars) {
        return getRatingPercent()*max_stars;
    }
    
    /** @return the playcount, 0 if empty. */
    @MetadataFieldMethod(Field.PLAYCOUNT)
    public int getPlaycount() {
        return playcount == -1 ? 0 : playcount;
    }
    
    /** 
     * tag field: grouping
     * @return the category "" if empty.
     */
    @MetadataFieldMethod(Field.CATEGORY)
    public String getCategory() {
        return category;
    }
    
    /** @return the comment, "" if empty. */
    @MetadataFieldMethod(Field.COMMENT)
    public String getComment() {
        return comment;
    }

    /**
     * @return the lyrics, "" if empty.
     */
    @MetadataFieldMethod(Field.LYRICS)
    public String getLyrics() {
        return lyrics;
    }

    /**  @return the mood, "" if empty. */
    @MetadataFieldMethod(Field.MOOD)
    public String getMood() {
        return mood;
    }
    
    /**  
     * Color is located in the Custom1 tag field.
     * @return the color value associated with the song from tag or {@link EMPTY_COLOR} if
     * none.
     */
    @MetadataFieldMethod(Field.COLOR)
    public Color getColor() {
         return custom1.isEmpty() ? EMPTY_COLOR : Parser.fromS(Color.class,custom1);
    }
    
    /** @return the value of custom1 field. "" if empty. */
    @MetadataFieldMethod(Field.CUSTOM1)
    public String getCustom1() {
        return custom1;
    }
    /** @return the value of custom2 field. "" if empty. */
    @MetadataFieldMethod(Field.CUSTOM2)
    public String getCustom2() {
        return custom2;
    }
    /** @return the value of custom3 field. "" if empty. */
    @MetadataFieldMethod(Field.CUSTOM3)
    public String getCustom3() {
        return custom3;
    }
    /** @return the value of custom4 field. "" if empty. */
    @MetadataFieldMethod(Field.CUSTOM4)
    public String getCustom4() {
        return custom4;
    }
    /** @return the value of custom5 field. "" if empty. */
    @MetadataFieldMethod(Field.CUSTOM5)
    public String getCustom5() {
        return custom5;
    }
    
/******************************************************************************/
    
    /**
     * Note: This is non-tag information.
     * @return some additional non-tag information
     */
    public MetadataExtended getExtended() {
        MetadataExtended me = new MetadataExtended(this);
                         me.readFromFile();
        return me;
    }
    
    /**
     * @return index of the item in playlist belonging to this metadata or -1 if
     * not on playlist.
     */
    public int getPlaylistIndex() {
        return PlaylistManager.getIndexOf(this)+1;
    }
    
    /**
     * Returns index of the item in playlist belonging to this metadata.
     * Convenience method. Example: "15/30". "Order/total" items in playlist.
     * Note: This is non-tag information.
     * @return Empty string if not on playlist.
     */
    public String getPlaylistIndexInfo() {
        int i = getPlaylistIndex();
        return i==-1 ? "" : i + "/" + PlaylistManager.getSize();
    }
    public static final boolean chaptersIncludeXML = true;
    /**
     * Returns chapters associated with this item. A {@link Chapter} represents
     * a time specific song comment. The result is ordered by natural order.
     * <p>
     * Chapters are concatenated into string located in the Custom2 tag field.
     * 
     * @return ordered list of chapters parsed from tag data
     */
    @MetadataFieldMethod(Field.CHAPTERS)
    public List<Chapter> getChapters() {
        String chapterString = getCustom2();
        if(chapterString.isEmpty()&&!chaptersIncludeXML) return EMPTY_LIST;
        
        List<Chapter> cs = new ArrayList();
        // we have got a regex over here so "||\" is equivalent to '\' character
        for(String c: getCustom2().split("\\|", 0)) {
            try {
                cs.add(new Chapter(c));
            } catch( IllegalArgumentException e) {
                Log.err("String '" + c + "' not be parsed as chapter. Will be ignored.");
                // ignore
            }
        }
        
        if(chaptersIncludeXML) cs.addAll(getChaptersFromXML());
        cs.sort(Chapter::compareTo);
        return cs;
    }
    
    /**
     * Legacy method.
     * Before chapters were written to tag they were contained within xml files
     * in the same directory as the item and the same file name (but xml suffix).
     * This method reads the file when it is invoked and parses its content.
     * <p>
     * This method should only be used when transferring information in legacy
     * xml files into tag.
     * <p>
     * The result is ordered by natural order.
     * @return ordered list of chapters parsed from xml data
     */
    private List<Chapter> getChaptersFromXML() {
        MetadataExtended me = new MetadataExtended(this);
                         me.readFromFile();
        List<Chapter> cs = me.getChapters();
                      cs.sort(Chapter::compareTo);
        return cs;
    }
    
    public boolean containsChapterAt(Duration at) {
        return getChapters().stream().anyMatch(ch->ch.getTime().equals(at));
    }

    /** {@inheritDoc} */
    @Override
    public Metadata toMeta() {
        return this;
    }

    /** {@inheritDoc} */
    @Override
    public PlaylistItem toPlaylist() {
        return new PlaylistItem(getURI(), getArtist(), getTitle(), getLengthInMs());
    }
    
/***************************** AS FIELDED TYPE ********************************/

    /** {@inheritDoc} */
    @Override
    public Object getField(Metadata.Field fieldType) {
        switch(fieldType) {
            case PATH :  return getPath();
            case FILENAME :  return getFilename();
            case FORMAT :  return getFormat();
            case FILESIZE : return getFilesize();
            case ENCODING : return getEncodingType();
            case BITRATE : return getBitrate();
            case ENCODER : return getEncoder();
            case CHANNELS : return getChannels();
            case SAMPLE_RATE : return getSampleRate();
            case LENGTH : return getLength();
            case TITLE : return getTitle();
            case ALBUM : return getAlbum();
            case ARTIST : return getArtist();
            case ALBUM_ARTIST : return getAlbumArtist();
            case COMPOSER : return getComposer();
            case PUBLISHER : return getPublisher();
            case TRACK : return getTrack();
            case TRACKS_TOTAL : return getTracksTotal();
            case TRACK_INFO : return getTrackInfo();
            case DISC : return getDisc();
            case DISCS_TOTAL : return getDiscsTotal();
            case DISCS_INFO : return getDiscInfo();
            case GENRE : return getGenre();
            case YEAR : return getYear();
            case COVER : return getCover();
            case COVER_INFO : return getCoverInfo();
            case RATING : return getRatingPercent();
            case RATING_RAW : return getRating();
            case PLAYCOUNT : return getPlaycount();
            case CATEGORY : return getCategory();
            case COMMENT : return getComment();
            case LYRICS : return getLyrics();
            case MOOD : return getMood();
            case COLOR : return getColor();
            case CHAPTERS : return getChapters();
            case CUSTOM1 : return getCustom1();
            case CUSTOM2 : return getCustom2();
            case CUSTOM3 : return getCustom3();
            case CUSTOM4 : return getCustom4();
            case CUSTOM5 : return getCustom5();
            default : throw new AssertionError("Default case should never execute");
        }
    }
    
    public String getFieldS(Field f) {
        Object o = getField(f);
        return o==null ? "<none>" : f.toS(o, "<none>");
    }
    
    public String getFieldS(Field f, String no_val) {
        Object o = getField(f);
        return o==null ? no_val : f.toS(o,no_val);
    }
    
    public boolean isFieldEmpty(Metadata.Field fieldType) {
        return EMPTY.getField(fieldType).equals(getField(fieldType));
    }
    
    /** {@inheritDoc} */
    @Override 
    public Field getMainField() { return Field.TITLE; }
    
/******************************* AS OBJECT ************************************/
    
    /** 
     * Complete information on this object, non-tag data and types not
     * representable by string (e.g. cover) are excluded.
     * @return comprehensive information about all string representable fields 
     */
    @Override
    public String toString() {
        return stream(Field.values()).filter(f->f.isTypeStringRepresentable())
            .map(f -> f.name() + ": " + getField(f)).collect(joining("\n"));
    }

    @Override
    public boolean equals(Object o) {
        if(this==o) return true;
        if (!(o instanceof Metadata)) return false;
        return Objects.equals(uri, ((Metadata)o).uri);
    }
    
    @Override
    public int hashCode() {
        int hash = 0;
        hash += (uri != null ? uri.hashCode() : 0);
        return hash;
    }

    @Override
    public int compareTo(Metadata i) {
        int r = getArtist().compareTo(i.getArtist());
        if (r!=0) return r;
            r = getAlbum().compareTo(i.getAlbum());
        if (r!=0) return r;
            r = Integer.compare(getDisc(), i.getDisc());
        if (r!=0) return r;
            r = Integer.compare(getTrack(), i.getTrack());
        if (r!=0) return r;
        return getTitle().compareTo(i.getTitle());
    }
    
/**************************** COMPANION CLASS *********************************/
    
    /**
     * 
     */
    public static enum Field implements FieldEnum<Metadata> {
        PATH("Song location"),
        FILENAME("Song file name without suffix"),
        FORMAT("Song file type "),
        FILESIZE("Song file size"),
        ENCODING("Song encoding"),
        BITRATE("Bits per second of the song - quality aspect. More is better."),
        ENCODER("Song encoder"),
        CHANNELS("Number of channels"),
        SAMPLE_RATE("Sample frequency"),
        LENGTH("Song length"),
        TITLE("Song title"),
        ALBUM("Song album"),
        ARTIST("Artist of the song"),
        ALBUM_ARTIST("Artist of the song album"),
        COMPOSER("Composer of the song"),
        PUBLISHER("Publisher of the album"),
        TRACK("Song number within album"),
        TRACKS_TOTAL("Number of songs in the album"),
        TRACK_INFO("Complete song number in format: track/track total"),
        DISC("Disc number within album"),
        DISCS_TOTAL("Number of discs in the album"),
        DISCS_INFO("Complete disc number in format: disc/disc total"),
        GENRE("Genre of the song"),
        YEAR("Year the album was published"),
        COVER("Cover of the song"),
        COVER_INFO("Cover information"),
        RATING("Song rating in 0-1 range"),
        RATING_RAW("Song rating tag value. Depends on tag type"),
        PLAYCOUNT("Number of times the song was played. Definition may vary."),
        CATEGORY("Category of the song. Arbitrary"),
        COMMENT("User comment of the song. Arbitrary"),
        LYRICS("Lyrics for the song"),
        MOOD("Mood the song evokes"),
        COLOR("Color the song evokes"),
        CHAPTERS("Comments at specific time points of the song"),
        CUSTOM1("Custom field 1. Reserved for chapters."),
        CUSTOM2("Custom field 2. Reserved for color."),
        CUSTOM3("Custom field 3"),
        CUSTOM4("Custom field 4"),
        CUSTOM5("Custom field 5");
        
        private final String desc;
        private final Function<Object,String> toS = Objects::toString;
        
        private Field(String desc) {
            mapEnumConstant(this, Util::enumToHuman);
            this.desc = desc;
        }

        @Override
        public String description() {
            return desc;
        }
        
        /** {@inheritDoc} */
        @Override
        public boolean isTypeStringRepresentable() {
            return this != COVER && this != CHAPTERS;
        }
        
        /** {@inheritDoc} */
        @Override
        public Class getType() {
            if(this==BITRATE) return Bitrate.class;
            return Metadata.EMPTY.getField(this).getClass();
        }

        /**
         * Returns true.
         * <p>
         * {@inheritDoc} 
         */
        @Override
        public boolean isTypeNumberNonegative() { return true; }
        
        public boolean isCommon() {
            return this==TITLE || this==ALBUM || this==ARTIST || this==RATING || this==PLAYCOUNT ||
                   this==LENGTH || this==BITRATE || this==TRACK_INFO || this==DISCS_INFO;
        }
        
        public boolean isAutoCompleteable() {
            return isTypeStringRepresentable() && !isIn(this, TITLE,RATING_RAW,
                COMMENT,LYRICS,COLOR,PLAYCOUNT,PATH,FILENAME,FILESIZE,ENCODING,
                LENGTH,TRACK,TRACKS_TOTAL,TRACK_INFO,DISC,DISCS_TOTAL,DISCS_INFO,
                COVER,COVER_INFO,RATING,CHAPTERS);
        }
        
        @Override
        public String toS(Object o, String empty_val) {
            switch(this) {
                case YEAR :
                case TRACK :
                case TRACKS_TOTAL :
                case DISC :
                case DISCS_TOTAL :  
                case PLAYCOUNT :    return EMPTY.getField(this).equals(o) ? empty_val : o.toString();
                case PATH :         
                case FILENAME :     
                case FORMAT :       
                case FILESIZE :     
                case ENCODING :     
                case BITRATE :      
                case ENCODER :      
                case CHANNELS :     
                case SAMPLE_RATE :  
                case LENGTH :       
                case TITLE :        
                case ALBUM :        
                case ARTIST :       
                case ALBUM_ARTIST : 
                case COMPOSER :     
                case PUBLISHER :    
                case TRACK_INFO :
                case DISCS_INFO :   
                case GENRE :        
                case COVER :        
                case COVER_INFO :   
                case RATING :       
                case RATING_RAW :   
                case CATEGORY :     
                case COMMENT :      
                case LYRICS :       
                case MOOD :         
                case COLOR :        
                case CHAPTERS :     
                case CUSTOM1 :      
                case CUSTOM2 :      
                case CUSTOM3 :      
                case CUSTOM4 :      
                case CUSTOM5 :      return o.toString();
                default : throw new AssertionError("Default case should never execute");
            }
        }
    }
    
    /** 
     * Supposed to be used for invoking getField() using reflection. Now used
     * only to annotate responsible methods, hence the retention being source.
     */
    @Retention(SOURCE)
    @Target(METHOD) 
    public static @interface MetadataFieldMethod {
        Field value();
    }
}